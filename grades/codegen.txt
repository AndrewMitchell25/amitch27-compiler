=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
i: integer = 10;
i2: integer;
s: string = "hello";
s2: string;
b: boolean = true;
b2: boolean;
c: char = 'h';
c2: char;
main: function integer () = {
    x: integer;
    print i, s, c, '\n';
    return 0;
}
===[good0.bminor Output]===
.data
.global i
i: .quad 10
.data
.global i2
i2: .quad 0
.data
.global s
s: .string "hello"
.data
.global s2
s2: .string ""
.data
.global b
b: .quad 1
.data
.global b2
b2: .quad 0
.data
.global c
c: .quad 104
.data
.global c2
c2: .quad 0
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ i, %rbx
MOVQ %rbx, %rdi
CALL print_integer
LEAQ s, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ c, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

10helloh


return code: 0


===[good1.bminor Input]===
compute: function integer ( a: integer, b: integer, c: integer ) =
{
    x:integer = a+b+c;
    y:integer = x-5;
    if(false){
        print x;
    } else {
        print y;
    }
    return y;
}

main: function integer () = {
    x: integer = compute(4, 2, 3);
    y: integer = compute(1, 2, 3);
    print x, y, x+2, '\n';
    return 0;
}

===[good1.bminor Output]===
.text
.global compute
compute:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
ADDQ %rbx, %r10
MOVQ -24(%rbp), %rbx
ADDQ %r10, %rbx
MOVQ %rbx, -32(%rbp)
MOVQ -32(%rbp), %rbx
MOVQ $5, %r10
SUBQ %r10, %rbx
MOVQ %rbx, -40(%rbp)
MOVQ $0, %rbx
CMP $0, %rbx
JE .L1
MOVQ -32(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
JMP .L2
.L1:
MOVQ -40(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.L2:
MOVQ -40(%rbp), %rbx
MOVQ %rbx, %rax
JMP .compute_epilogue
##############
.compute_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $4, %rbx
MOVQ %rbx, %rdi
MOVQ $2, %rbx
MOVQ %rbx, %rsi
MOVQ $3, %rbx
MOVQ %rbx, %rdx
PUSHQ %r10
PUSHQ %r11
CALL compute
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $1, %rbx
MOVQ %rbx, %rdi
MOVQ $2, %rbx
MOVQ %rbx, %rsi
MOVQ $3, %rbx
MOVQ %rbx, %rdx
PUSHQ %r10
PUSHQ %r11
CALL compute
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

41416


return code: 0


===[good10.bminor Input]===
a: array [5] integer = {0, 0, 0, 0, 0};
f: function void (x: integer) = {
    i: integer;
    for(i=0; i<x;i++){
        a[i] = i;
    }
    for(i=0; i<x;i++){
        print a[i];
    }
    print '\n';
    return;
}

main: function integer () = {
    f(5);
    a[0]++;
    a[1]++;
    a[2]--;
    i: integer;
    for(i=0; i<5;i++){
        print a[i];
    }
    print '\n';
    return 0;
}
===[good10.bminor Output]===
.data
.global a
a: .quad 0, 0, 0, 0, 0
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -16(%rbp)
.L1:
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
CMP %rbx, %r10
JG .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
MOVQ -16(%rbp), %rbx
LEAQ a, %r10
MOVQ -16(%rbp), %r11
MOVQ %rbx, (%r10, %r11, 8)
MOVQ -16(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -16(%rbp)
JMP .L1
.L2:
MOVQ $0, %rbx
MOVQ %rbx, -16(%rbp)
.L5:
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
CMP %rbx, %r10
JG .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L6
LEAQ a, %rbx
MOVQ -16(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ %r11, %rdi
CALL print_integer
MOVQ -16(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -16(%rbp)
JMP .L5
.L6:
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $5, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
LEAQ a, %rbx
MOVQ $0, %r10
MOVQ (%rbx, %r10, 8), %r11
INCQ %r11
LEAQ a, %rbx
MOVQ $0, %r10
MOVQ %r11, (%rbx, %r10, 8)
LEAQ a, %rbx
MOVQ $1, %r10
MOVQ (%rbx, %r10, 8), %r11
INCQ %r11
LEAQ a, %rbx
MOVQ $1, %r10
MOVQ %r11, (%rbx, %r10, 8)
LEAQ a, %rbx
MOVQ $2, %r10
MOVQ (%rbx, %r10, 8), %r11
DECQ %r11
LEAQ a, %rbx
MOVQ $2, %r10
MOVQ %r11, (%rbx, %r10, 8)
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L9:
MOVQ -8(%rbp), %rbx
MOVQ $5, %r10
CMP %rbx, %r10
JG .L11
MOVQ $0, %rbx
JMP .L12
.L11:
MOVQ $1, %rbx
.L12:
CMP $0, %rbx
JE .L10
LEAQ a, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ %r11, %rdi
CALL print_integer
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L9
.L10:
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

01234
12134


return code: 0


===[good11.bminor Input]===
f: function void (x: integer) = {
    a: array [x] integer;
    i: integer;
    for(i=0; i<x;i++){
        a[i] = i;
    }
    print x;
    for(i=0; i<x;i++){
        print a[i];
    }
    print x;
    print '\n';
    return;
}

main: function integer () = {
    f(7);
    return 0;
}
===[good11.bminor Output]===
TEST NOT PASSED - RUNTIME ERROR



return code: -11


===[good12.bminor Input]===
i:char= 'i';

d: function char () = {
    return 'd';
}

main:function integer () =
{
	n:char ='n';
	print 'h', i,' ', n, d(), '\n'; 
	return 0;
}
===[good12.bminor Output]===
.data
.global i
i: .quad 105
.text
.global d
d:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $100, %rbx
MOVQ %rbx, %rax
JMP .d_epilogue
##############
.d_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $110, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $104, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ i, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_character
PUSHQ %r10
PUSHQ %r11
CALL d
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

hi nd


return code: 0


===[good13.bminor Input]===
a: char = 'a';
main: function integer () = {
    b: char = 'b';
    c: char = 'c';
    c2: char = 'c';

    if(!(c==a)) {
        print "yes\n";
    } else {
        print "no\n";
    }

    if(c==c2) {
        print "yes\n";
    } else {
        print "no\n";
    }

    if(c>a) {
        print "yes\n";
    } else {
        print "no\n";
    }

    if(c==a) {
        print "no\n";
    } else {
        print "yes\n";
    }

    return 0;
}
===[good13.bminor Output]===
.data
.global a
a: .quad 97
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $98, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $99, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ $99, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ a, %r10
CMP %rbx, %r10
JE .L1
MOVQ $0, %rbx
JMP .L2
.L1:
MOVQ $1, %rbx
.L2:
CMP $0, %rbx
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L5
.data
.L7: .string "yes\n"
.text
LEAQ .L7, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L6
.L5:
.data
.L8: .string "no\n"
.text
LEAQ .L8, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L6:
MOVQ -16(%rbp), %rbx
MOVQ -24(%rbp), %r10
CMP %rbx, %r10
JE .L9
MOVQ $0, %rbx
JMP .L10
.L9:
MOVQ $1, %rbx
.L10:
CMP $0, %rbx
JE .L11
.data
.L13: .string "yes\n"
.text
LEAQ .L13, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L12
.L11:
.data
.L14: .string "no\n"
.text
LEAQ .L14, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L12:
MOVQ -16(%rbp), %rbx
MOVQ a, %r10
CMP %rbx, %r10
JL .L15
MOVQ $0, %rbx
JMP .L16
.L15:
MOVQ $1, %rbx
.L16:
CMP $0, %rbx
JE .L17
.data
.L19: .string "yes\n"
.text
LEAQ .L19, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L18
.L17:
.data
.L20: .string "no\n"
.text
LEAQ .L20, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L18:
MOVQ -16(%rbp), %rbx
MOVQ a, %r10
CMP %rbx, %r10
JE .L21
MOVQ $0, %rbx
JMP .L22
.L21:
MOVQ $1, %rbx
.L22:
CMP $0, %rbx
JE .L23
.data
.L25: .string "no\n"
.text
LEAQ .L25, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L24
.L23:
.data
.L26: .string "yes\n"
.text
LEAQ .L26, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L24:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

yes
yes
yes
yes


return code: 0


===[good14.bminor Input]===
// tests for loops
main: function integer () =
{
    i:integer = 0;
	for(i = 0; i<3; i++)
	{
		print i, "\n";
	}
	i = 0;
	for(; i<3;)
	{
		print i, "\n";
        i++;
	}
    i = 3;
    for(;;) {
		print i, "\n";
        if(i>0){
            i--;
        } else {
            return i;
        }
    }
}
===[good14.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L1:
MOVQ -8(%rbp), %rbx
MOVQ $3, %r10
CMP %rbx, %r10
JG .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L5: .string "\n"
.text
LEAQ .L5, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L1
.L2:
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L6:
MOVQ -8(%rbp), %rbx
MOVQ $3, %r10
CMP %rbx, %r10
JG .L8
MOVQ $0, %rbx
JMP .L9
.L8:
MOVQ $1, %rbx
.L9:
CMP $0, %rbx
JE .L7
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L10: .string "\n"
.text
LEAQ .L10, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L6
.L7:
MOVQ $3, %rbx
MOVQ %rbx, -8(%rbp)
.L11:
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L13: .string "\n"
.text
LEAQ .L13, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JL .L14
MOVQ $0, %rbx
JMP .L15
.L14:
MOVQ $1, %rbx
.L15:
CMP $0, %rbx
JE .L16
MOVQ -8(%rbp), %rbx
DECQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L17
.L16:
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
.L17:
JMP .L11
.L12:
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

0
1
2
0
1
2
3
2
1
0


return code: 0


===[good15.bminor Input]===
x:integer=5;
f:function integer() =
{
	return x*4;
}
main:function integer () =
{
	y:integer = 2;
	return (x - 10) * y + f();
}
===[good15.bminor Output]===
.data
.global x
x: .quad 5
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ x, %rbx
MOVQ $4, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $2, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ x, %rbx
MOVQ $10, %r10
SUBQ %r10, %rbx
MOVQ -8(%rbp), %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 10


===[good16.bminor Input]===
d: char = 'd';
main: function integer () = {
    s: string = " wor";
    print 'h', "ello", s, 1, d, '\n';
    return 0;
}
===[good16.bminor Output]===
.data
.global d
d: .quad 100
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string " wor"
.text
LEAQ .L1, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $104, %rbx
MOVQ %rbx, %rdi
CALL print_character
.data
.L2: .string "ello"
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $1, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ d, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

hello wor1d


return code: 0


===[good17.bminor Input]===
f: function integer (i: integer) = {
    print i, ' ';
    if(i==0) {
        return 0;
    }
    return f(i--);
}

main: function integer () = {
    f(10);
    print '\n';
    return 0;
}
===[good17.bminor Output]===
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -8(%rbp), %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JE .L1
MOVQ $0, %rbx
JMP .L2
.L1:
MOVQ $1, %rbx
.L2:
CMP $0, %rbx
JE .L3
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .f_epilogue
JMP .L4
.L3:
.L4:
MOVQ -8(%rbp), %rbx
DECQ %rbx
MOVQ %rbx, -8(%rbp)
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $10, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

10 9 8 7 6 5 4 3 2 1 0 


return code: 0


===[good18.bminor Input]===
//checking to make sure registers are freed with very long math equation
//should print 11
main: function integer () = {
    print (1+2) * 4 / 2 - 3 + -2 + (5*2*1*1*1*1*1*1*1), '\n';
    return 0;
}
===[good18.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $1, %rbx
MOVQ $2, %r10
ADDQ %rbx, %r10
MOVQ $4, %rbx
MOVQ %r10, %rax
IMULQ %rbx
MOVQ %rax, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %rbx
MOVQ $3, %r10
SUBQ %r10, %rbx
MOVQ $2, %r10
MOVQ $0, %r11
SUBQ %r10, %r11
ADDQ %rbx, %r11
MOVQ $5, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
ADDQ %r11, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

11


return code: 0


===[good19.bminor Input]===
//prints the command line arguments back

main: function integer (argc: integer, argv: array [] string) = {
    i: integer = 0;
    for(;i<argc;i++){
        print argv[i], ' ';
    }
    print '\n';
    return 0;
}
===[good19.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -24(%rbp)
.L1:
MOVQ -24(%rbp), %rbx
MOVQ -8(%rbp), %r10
CMP %rbx, %r10
JG .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
MOVQ -16(%rbp), %rbx
MOVQ -24(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ %r11, %rdi
CALL print_string
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -24(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -24(%rbp)
JMP .L1
.L2:
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

./amitch27-compiler/test/codegen/good19.bminor.bin 


return code: 0


===[good2.bminor Input]===
s: string = "hello\n";
main: function integer () = {
    print 4+2, " ", 4-2, " ", 4*2, " ", 4/2, " ", 4++, " ", 4--, " ", 5%2, "\n";
    print s;
    return 0;
}
===[good2.bminor Output]===
.data
.global s
s: .string "hello\n"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $4, %rbx
MOVQ $2, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
.data
.L1: .string " "
.text
LEAQ .L1, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $4, %rbx
MOVQ $2, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L2: .string " "
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $4, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L3: .string " "
.text
LEAQ .L3, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $4, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L4: .string " "
.text
LEAQ .L4, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $4, %rbx
INCQ %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L5: .string " "
.text
LEAQ .L5, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $4, %rbx
DECQ %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L6: .string " "
.text
LEAQ .L6, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $5, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L7: .string "\n"
.text
LEAQ .L7, %rbx
MOVQ %rbx, %rdi
CALL print_string
LEAQ s, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

6 2 8 2 5 3 1
hello


return code: 0


===[good3.bminor Input]===
main: function integer () = {
    s1: string = "hello";
    s2: string = "hello";
    if (s1 == s2)
        print "compared contents\n";
    else
        print "compared addresses\n";
    return 0;
}
===[good3.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string "hello"
.text
LEAQ .L1, %rbx
MOVQ %rbx, -8(%rbp)
.data
.L2: .string "hello"
.text
LEAQ .L2, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
CMP %rbx, %r10
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L5
.data
.L7: .string "compared contents\n"
.text
LEAQ .L7, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L6
.L5:
.data
.L8: .string "compared addresses\n"
.text
LEAQ .L8, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L6:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

compared addresses


return code: 0


===[good4.bminor Input]===
main: function integer () = {
    if(3 == 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(3 != 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(3 < 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(4 <= 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(3 > 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(3 >= 4) {
        print "true\n";
    } else {
        print "false\n";
    }
    if(3 == 3 && 4==4) {
        print "true\n";
    } else {
        print "false\n";
    }
    return 0;
}
===[good4.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JE .L1
MOVQ $0, %rbx
JMP .L2
.L1:
MOVQ $1, %rbx
.L2:
CMP $0, %rbx
JE .L3
.data
.L5: .string "true\n"
.text
LEAQ .L5, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L4
.L3:
.data
.L6: .string "false\n"
.text
LEAQ .L6, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L4:
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JNE .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L9
.data
.L11: .string "true\n"
.text
LEAQ .L11, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L10
.L9:
.data
.L12: .string "false\n"
.text
LEAQ .L12, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L10:
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JG .L13
MOVQ $0, %rbx
JMP .L14
.L13:
MOVQ $1, %rbx
.L14:
CMP $0, %rbx
JE .L15
.data
.L17: .string "true\n"
.text
LEAQ .L17, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L16
.L15:
.data
.L18: .string "false\n"
.text
LEAQ .L18, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L16:
MOVQ $4, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JGE .L19
MOVQ $0, %rbx
JMP .L20
.L19:
MOVQ $1, %rbx
.L20:
CMP $0, %rbx
JE .L21
.data
.L23: .string "true\n"
.text
LEAQ .L23, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L22
.L21:
.data
.L24: .string "false\n"
.text
LEAQ .L24, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L22:
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JL .L25
MOVQ $0, %rbx
JMP .L26
.L25:
MOVQ $1, %rbx
.L26:
CMP $0, %rbx
JE .L27
.data
.L29: .string "true\n"
.text
LEAQ .L29, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L28
.L27:
.data
.L30: .string "false\n"
.text
LEAQ .L30, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L28:
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JLE .L31
MOVQ $0, %rbx
JMP .L32
.L31:
MOVQ $1, %rbx
.L32:
CMP $0, %rbx
JE .L33
.data
.L35: .string "true\n"
.text
LEAQ .L35, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L34
.L33:
.data
.L36: .string "false\n"
.text
LEAQ .L36, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L34:
MOVQ $3, %rbx
MOVQ $3, %r10
CMP %rbx, %r10
JE .L37
MOVQ $0, %rbx
JMP .L38
.L37:
MOVQ $1, %rbx
.L38:
MOVQ $4, %r10
MOVQ $4, %r11
CMP %r10, %r11
JE .L39
MOVQ $0, %r10
JMP .L40
.L39:
MOVQ $1, %r10
.L40:
CMP $0, %rbx
JNE .L41
MOVQ $0, %r10
.L41:
CMP $0, %r10
JE .L42
.data
.L44: .string "true\n"
.text
LEAQ .L44, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L43
.L42:
.data
.L45: .string "false\n"
.text
LEAQ .L45, %rbx
MOVQ %rbx, %rdi
CALL print_string
.L43:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

false
true
true
true
false
false
true


return code: 0


===[good5.bminor Input]===
//for loops

main: function integer () = {
    i: integer = 10;
    for(i=0; i<=10; i++){
        print "i ", i, "\n";
    }
    j:integer;
    for(j=i; j>=0; j=j-2){
        print "j ", j, "\n";
    }

    for(;;){
        print j, "\n";
        j++;
        if(j > 10) {
            return j;
        }
    }
    return 0;
}
===[good5.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $10, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L1:
MOVQ -8(%rbp), %rbx
MOVQ $10, %r10
CMP %rbx, %r10
JGE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
.data
.L5: .string "i "
.text
LEAQ .L5, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L6: .string "\n"
.text
LEAQ .L6, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L1
.L2:
MOVQ -8(%rbp), %rbx
MOVQ %rbx, -16(%rbp)
.L7:
MOVQ -16(%rbp), %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JLE .L9
MOVQ $0, %rbx
JMP .L10
.L9:
MOVQ $1, %rbx
.L10:
CMP $0, %rbx
JE .L8
.data
.L11: .string "j "
.text
LEAQ .L11, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L12: .string "\n"
.text
LEAQ .L12, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -16(%rbp), %rbx
MOVQ $2, %r10
SUBQ %r10, %rbx
MOVQ %rbx, -16(%rbp)
JMP .L7
.L8:
.L13:
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L15: .string "\n"
.text
LEAQ .L15, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -16(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ $10, %r10
CMP %rbx, %r10
JL .L16
MOVQ $0, %rbx
JMP .L17
.L16:
MOVQ $1, %rbx
.L17:
CMP $0, %rbx
JE .L18
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L19
.L18:
.L19:
JMP .L13
.L14:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

i 0
i 1
i 2
i 3
i 4
i 5
i 6
i 7
i 8
i 9
i 10
j 11
j 9
j 7
j 5
j 3
j 1
-1
0
1
2
3
4
5
6
7
8
9
10


return code: 11


===[good6.bminor Input]===
a: array [4] integer = {1, 2, 3, 0};
b: array [4] integer = {4, 3, 2, 1};
c: char = 'h';
t: boolean = true;

main: function integer () = {
    print b[a[3]];
    print true, 'a', !(3>4), -10-4, '\n';
    return 0;
}
===[good6.bminor Output]===
.data
.global a
a: .quad 1, 2, 3, 0
.data
.global b
b: .quad 4, 3, 2, 1
.data
.global c
c: .quad 104
.data
.global t
t: .quad 1
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
LEAQ b, %rbx
LEAQ a, %r10
MOVQ $3, %r11
MOVQ (%r10, %r11, 8), %r12
MOVQ (%rbx, %r12, 8), %r10
MOVQ %r10, %rdi
CALL print_integer
MOVQ $1, %rbx
MOVQ %rbx, %rdi
CALL print_boolean
MOVQ $97, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $3, %rbx
MOVQ $4, %r10
CMP %rbx, %r10
JL .L1
MOVQ $0, %rbx
JMP .L2
.L1:
MOVQ $1, %rbx
.L2:
CMP $0, %rbx
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
MOVQ %rbx, %rdi
CALL print_boolean
MOVQ $10, %rbx
MOVQ $0, %r10
SUBQ %rbx, %r10
MOVQ $4, %rbx
SUBQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

4trueatrue-14


return code: 0


===[good7.bminor Input]===
f: function void (a: integer, b: integer, c: integer, d: integer, e: integer, f: integer) = {
    print a, ' ', b, ' ', c, ' ', d, ' ', e, ' ', f, '\n';
    return;
}

f2: function integer() = {
    return 3;
}

main: function integer () = {
    f(1, 2, 3, 4, 5, 6);
    print f2(), '\n';
    return 0;
}
===[good7.bminor Output]===
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -32(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -40(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -48(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global f2
f2:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $3, %rbx
MOVQ %rbx, %rax
JMP .f2_epilogue
##############
.f2_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $1, %rbx
MOVQ %rbx, %rdi
MOVQ $2, %rbx
MOVQ %rbx, %rsi
MOVQ $3, %rbx
MOVQ %rbx, %rdx
MOVQ $4, %rbx
MOVQ %rbx, %rcx
MOVQ $5, %rbx
MOVQ %rbx, %r8
MOVQ $6, %rbx
MOVQ %rbx, %r9
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
PUSHQ %r10
PUSHQ %r11
CALL f2
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

1 2 3 4 5 6
3


return code: 0


===[good8.bminor Input]===
main: function integer () = {
    print true && true, ' ', true && false, ' ', false && false, ' ', false && true, ' ', true || true, ' ', false || true, ' ', true || false, ' ', false || false, '\n';
    return 0;
}
===[good8.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $1, %rbx
MOVQ $1, %r10
CMP $0, %rbx
JNE .L1
MOVQ $0, %r10
.L1:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $1, %rbx
MOVQ $0, %r10
CMP $0, %rbx
JNE .L2
MOVQ $0, %r10
.L2:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ $0, %r10
CMP $0, %rbx
JNE .L3
MOVQ $0, %r10
.L3:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ $1, %r10
CMP $0, %rbx
JNE .L4
MOVQ $0, %r10
.L4:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $1, %rbx
MOVQ $1, %r10
CMP $1, %rbx
JNE .L5
MOVQ $1, %r10
.L5:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ $1, %r10
CMP $1, %rbx
JNE .L6
MOVQ $1, %r10
.L6:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $1, %rbx
MOVQ $0, %r10
CMP $1, %rbx
JNE .L7
MOVQ $1, %r10
.L7:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ $0, %r10
CMP $1, %rbx
JNE .L8
MOVQ $1, %r10
.L8:
MOVQ %r10, %rdi
CALL print_boolean
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

true false false false true true true false


return code: 0


===[good9.bminor Input]===
main: function integer (argc: integer) = {
    return argc % 2;
}
===[good9.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 1


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===
.text
.global strlen
.text
.global f
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string "hi"
.text
LEAQ .L1, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
.data
.L2: .string "there"
.text
LEAQ .L2, %r10
MOVQ %r10, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
CMP %rbx, %r10
JL .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L5
.data
.L7: .string "no\n"
.text
LEAQ .L7, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L6
.L5:
.L6:
.data
.L8: .string "hi"
.text
LEAQ .L8, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
.data
.L9: .string "there"
.text
LEAQ .L9, %r10
MOVQ %r10, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
CMP %rbx, %r10
JL .L10
MOVQ $0, %rbx
JMP .L11
.L10:
MOVQ $1, %rbx
.L11:
CMP $0, %rbx
JE .L12
.data
.L14: .string "ok\n"
.text
LEAQ .L14, %rbx
MOVQ %rbx, %rdi
CALL print_string
JMP .L13
.L12:
.L13:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

ok


return code: 0


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===
.data
.global w
w: .string "no"
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string "ok"
.text
LEAQ .L1, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
.data
.L2: .string "\n"
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
.data
.L3: .string "bad!\n"
.text
LEAQ .L3, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
LEAQ w, %rbx
MOVQ %rbx, %rdi
CALL print_string
.data
.L4: .string " "
.text
LEAQ .L4, %rbx
MOVQ %rbx, %rdi
CALL print_string
.data
.L5: .string "changed\n"
.text
LEAQ .L5, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L6: .string "good"
.text
LEAQ .L6, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

ok
good no changed
good

return code: 0


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $40, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $20, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, -16(%rbp)
MOVQ $10, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -24(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $2, %rbx
MOVQ %rbx, -32(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -32(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $3, %rbx
MOVQ %rbx, -40(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -40(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 95


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
.text
.global foo_epilogue
foo_epilogue:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $2, %rbx
MOVQ %rbx, %rax
JMP .foo_epilogue_epilogue
##############
.foo_epilogue_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global foo
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
PUSHQ %r10
PUSHQ %r11
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $11, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main_epilogue
main_epilogue:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
PUSHQ %r10
PUSHQ %r11
CALL foo_epilogue
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $3, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP .main_epilogue_epilogue
##############
.main_epilogue_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
PUSHQ %r10
PUSHQ %r11
CALL main_epilogue
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rax
JMP .foo_epilogue
##############
.foo_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 44


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $4, %rbx
MOVQ $9, %r10
MOVQ $2, %r11
MOVQ $0, %r12
SUBQ %r11, %r12
MOVQ $5, %r11
MOVQ $0, %r13
SUBQ %r11, %r13
SUBQ %r13, %r12
MOVQ %r10, %rax
CQO
IDIVQ %r12
MOVQ %rax, %r10
ADDQ %rbx, %r10
MOVQ $2, %rbx
MOVQ $1, %r11
ADDQ %rbx, %r11
MOVQ $4, %rbx
MOVQ %r11, %rax
IMULQ %rbx
MOVQ %rax, %rbx
MOVQ $1, %r11
SUBQ %r11, %rbx
MOVQ $3, %r11
MOVQ %rbx, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %rbx
MOVQ $7, %r11
MOVQ %rbx, %rax
IMULQ %r11
MOVQ %rax, %rbx
ADDQ %r10, %rbx
MOVQ $8, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 13


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===
.text
.global strdup
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string "sssss"
.text
LEAQ .L1, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strdup
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
CMP %rbx, %r10
JE .L2
MOVQ $0, %rbx
JMP .L3
.L2:
MOVQ $1, %rbx
.L3:
CMP $0, %rbx
JE .L4
MOVQ $22, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L5
.L4:
MOVQ $11, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
.L5:
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 11


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===
TEST NOT PASSED

parse error on line 8: syntax error, unexpected TOKEN_NOT


return code: 1


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===
.data
.global b1
b1: .quad 3
.data
.global b2
b2: .quad 6
.data
.global b3
b3: .quad 9
.text
.global B
B:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ b1, %rbx
MOVQ b2, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $37, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rax
JMP .B_epilogue
##############
.B_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $5, %rbx
MOVQ %rbx, %rdi
MOVQ $3, %rbx
MOVQ %rbx, %rsi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ b3, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

20
37

return code: 9


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
.text
.global collatz
collatz:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L1: .string " "
.text
LEAQ .L1, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L2: .string "\n"
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
CMP %rbx, %r10
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L5
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rax
JMP .collatz_epilogue
JMP .L6
.L5:
.L6:
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JE .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L9
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
MOVQ -16(%rbp), %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .collatz_epilogue
JMP .L10
.L9:
MOVQ $3, %rbx
MOVQ -8(%rbp), %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
MOVQ -16(%rbp), %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .collatz_epilogue
.L10:
##############
.collatz_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $27, %rbx
MOVQ %rbx, %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111


return code: 111


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.text
.global D
D:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $64, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $5, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $9, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -24(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ $3, %rbx
SUBQ %rbx, %r10
MOVQ %r10, -32(%rbp)
MOVQ $1, %rbx
MOVQ $0, %r10
SUBQ %rbx, %r10
MOVQ %r10, -40(%rbp)
MOVQ -32(%rbp), %rbx
MOVQ -24(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -32(%rbp)
MOVQ -32(%rbp), %rbx
MOVQ -40(%rbp), %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L1: .string "\n"
.text
LEAQ .L1, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $16, %rbx
MOVQ %rbx, -48(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -48(%rbp), %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $2, %rbx
MOVQ $0, %r10
SUBQ %rbx, %r10
MOVQ %r10, -56(%rbp)
MOVQ $1000, %rbx
MOVQ %rbx, -64(%rbp)
MOVQ -64(%rbp), %rbx
MOVQ $10, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
.data
.L2: .string "\n"
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ -56(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -48(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $3, %rbx
MOVQ %rbx, %rax
JMP .D_epilogue
##############
.D_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
PUSHQ %r10
PUSHQ %r11
CALL D
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

21
-10
1010
-2
16

return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
.data
.global T
T: .quad 2, 1, 1, 2, 1, 2, 0, 3
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L1:
LEAQ T, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $0, %rbx
CMP %r11, %rbx
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L5
LEAQ T, %rbx
MOVQ $5, %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $10, %rbx
ADDQ %r11, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L6
.L5:
LEAQ T, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $1, %rbx
CMP %r11, %rbx
JE .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L9
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L10
.L9:
LEAQ T, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $2, %rbx
CMP %r11, %rbx
JE .L11
MOVQ $0, %rbx
JMP .L12
.L11:
MOVQ $1, %rbx
.L12:
CMP $0, %rbx
JE .L13
LEAQ T, %rbx
MOVQ -8(%rbp), %r10
INCQ %r10
MOVQ %r10, -8(%rbp)
MOVQ (%rbx, %r10, 8), %r11
DECQ %r11
LEAQ T, %rbx
MOVQ -8(%rbp), %r10
INCQ %r10
MOVQ %r10, -8(%rbp)
MOVQ %r11, (%rbx, %r10, 8)
JMP .L14
.L13:
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
.L14:
.L10:
.L6:
JMP .L1
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 12


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===
.text
.global A
.text
.global B
.text
.global C
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $100, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rsi
PUSHQ %r10
PUSHQ %r11
CALL A
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
CMP $0, %rbx
JE .L1
MOVQ $3, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $2, %rbx
MOVQ $33, %r10
MOVQ %r10, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %rbx, %rax
IMULQ %r10
MOVQ %rax, %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L2
.L1:
.L2:
.data
.L3: .string "hello"
.text
LEAQ .L3, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL C
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $3, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global A
A:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
CMP %rbx, %r10
JE .L4
MOVQ $0, %rbx
JMP .L5
.L4:
MOVQ $1, %rbx
.L5:
MOVQ %rbx, %rax
JMP .A_epilogue
##############
.A_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global B
B:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
MOVQ $33, %r10
CMP %rbx, %r10
JE .L6
MOVQ $0, %rbx
JMP .L7
.L6:
MOVQ $1, %rbx
.L7:
CMP $0, %rbx
JE .L8
MOVQ $10, %rbx
MOVQ %rbx, %rax
JMP .B_epilogue
JMP .L9
.L8:
MOVQ $11, %rbx
MOVQ %rbx, %rax
JMP .B_epilogue
.L9:
##############
.B_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global C
C:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $33, %rbx
MOVQ %rbx, %rax
JMP .C_epilogue
##############
.C_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 23


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ -8(%rbp), %rbx
CMP $0, %rbx
JE .L1
MOVQ $0, %rbx
JMP .L2
.L1:
MOVQ $1, %rbx
.L2:
MOVQ %rbx, %rax
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.data
.global x
x: .quad 0
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $10, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ x, %rbx
MOVQ -8(%rbp), %r10
CMP %rbx, %r10
JGE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
CMP $0, %rbx
JE .L5
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L6
.L5:
MOVQ x, %rbx
MOVQ -8(%rbp), %r10
MOVQ x, %r11
MOVQ -8(%rbp), %r12
MOVQ %r11, %rax
IMULQ %r12
MOVQ %rax, %r11
SUBQ %r11, %r10
CMP %rbx, %r10
JG .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L9
MOVQ $4, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L10
.L9:
MOVQ $2, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
.L10:
.L6:
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 4


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===[good7.bminor Output]===
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -16(%rbp)
.L1:
MOVQ -8(%rbp), %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JL .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ -16(%rbp), %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -8(%rbp), %rbx
DECQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L1
.L2:
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $6, %rbx
MOVQ %rbx, -8(%rbp)
.L5:
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -8(%rbp), %rbx
MOVQ $0, %r10
CMP %rbx, %r10
JE .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L9
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
JMP .L10
.L9:
.L10:
MOVQ -8(%rbp), %rbx
DECQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L5
.L6:
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

012345
01234
0123
012
01
0



return code: 0


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
TEST NOT PASSED



return code: -11


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===
.data
.global X
X: .quad 11, 30, 22, 0
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L1:
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $0, %rbx
CMP %r11, %rbx
JNE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ %r11, %rdi
CALL print_integer
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
MOVQ (%rbx, %r10, 8), %r11
MOVQ $3, %rbx
MOVQ %r11, %rax
CQO
IDIVQ %rbx
MOVQ %rdx, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ -8(%rbp), %rbx
INCQ %rbx
MOVQ %rbx, -8(%rbp)
JMP .L1
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

11 2
30 0
22 1


return code: 0


===[good8.bminor Input]===
abs: function integer(n: integer) = {
	return n;
}

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
TEST NOT PASSED - RUNTIME ERROR



return code: -11


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
.data
.global c1
c1: .quad 0
.data
.global c3
c3: .quad 100
.data
.global d1
d1: .quad 1
.data
.global d2
d2: .quad 2
.text
.global C
C:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $11, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ $12, %rbx
MOVQ %rbx, -32(%rbp)
MOVQ $13, %rbx
MOVQ %rbx, -40(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
ADDQ %rbx, %r10
MOVQ -24(%rbp), %rbx
ADDQ %r10, %rbx
MOVQ -32(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP .C_epilogue
##############
.C_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global D
D:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $3, %rbx
MOVQ $0, %r10
SUBQ %rbx, %r10
MOVQ %r10, -24(%rbp)
MOVQ $4, %rbx
MOVQ %rbx, -32(%rbp)
MOVQ $5, %rbx
MOVQ %rbx, -40(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
ADDQ %rbx, %r10
MOVQ -24(%rbp), %rbx
ADDQ %r10, %rbx
MOVQ -32(%rbp), %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rax
JMP .D_epilogue
##############
.D_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
MOVQ $6, %rbx
MOVQ %rbx, %rdi
MOVQ $7, %rbx
MOVQ %rbx, %rsi
PUSHQ %r10
PUSHQ %r11
CALL D
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $1, %rbx
MOVQ %rbx, %rdi
MOVQ $2, %rbx
MOVQ %rbx, %rsi
PUSHQ %r10
PUSHQ %r11
CALL C
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 26


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===
.data
.global s
s: .string "ok\n"
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
LEAQ s, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rax
JMP .f_epilogue
##############
.f_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

ok


return code: 0


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
##############
.data
.L1: .string "Testing printing literals"
.text
LEAQ .L1, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
MOVQ $123, %rbx
MOVQ %rbx, %rdi
CALL print_integer
.data
.L2: .string "abc"
.text
LEAQ .L2, %rbx
MOVQ %rbx, %rdi
CALL print_string
MOVQ $1, %rbx
MOVQ %rbx, %rdi
CALL print_boolean
MOVQ $0, %rbx
MOVQ %rbx, %rdi
CALL print_boolean
MOVQ $5, %rbx
MOVQ %rbx, %rdi
CALL print_integer
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP .main_epilogue
##############
.main_epilogue:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
MOVQ %rbp, %rsp
POPQ %rbp
RET

Testing printing literals
123abctruefalse5

return code: 0


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 19,
      "incorrect": 1
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 17,
      "incorrect": 3
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 25/25
---------------------------------
Overall structure is correct.

Codegen - Functionality 13/15 
--------------------------------------------
Some program crashes, potentially with arrays


Codegen - Assembly Structure 10/10 
--------------------------------------------
Assembly code looks good

Student Tests: 19/20
---------------------------
Fails 1 test

Hidden Tests: 17/20
---------------------------
Crashes/Fails 3 hidden tests

Code Style: 10/10
------------------------
Looks good. Nice work

Extra Credit: 0/10
------------------------

Total: 94/100
------------------------------------------
